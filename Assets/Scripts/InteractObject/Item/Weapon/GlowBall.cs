/*using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace KidGame.Core
{
    public class GlowBall : WeaponBase
    {
        private float checkRadius = 3f;
        private bool isEnemyHere = false;
        private bool isStartCoroutine = false;
        private Collider enemyCollider = null;


        #region 贝塞尔曲线相关变量
        private Vector3[] bezierPoints; // 贝塞尔曲线点集合
        private int currentPointIndex = 0;
        private bool isFollowingBezier = true;
        private float bezierSpeed = 10f; // 贝塞尔曲线移动速度
        private bool isSimulateEnd = false;
        #endregion
        protected override void Awake()
        {
            // 初始化贝塞尔曲线
            this.InitLineRender();
        }

        protected override void Start()
        {
            base.Start();
            if (lineRenderScript != null && lineRenderScript.GetPoints() != null && !isOnHand)
            {
                bezierPoints = lineRenderScript.GetPoints();
                isFollowingBezier = bezierPoints.Length > 1;
                if (isFollowingBezier)
                {
                    transform.position = bezierPoints[0]; // 设置初始位置为第1个点
                }
                for (int i = 1; i < bezierPoints.Length; i++)
                    Debug.Log(bezierPoints[i]);
            }
        }
        protected override void Update()
        {
            base.Update();
            // 如果在手上就持续更新贝塞尔曲线的点集
            // 否则开始移动
            if(isOnHand) SetbezierPoints(bezierPoints);
            else
            {
                // 进入了这里
                if (isFollowingBezier && bezierPoints != null && currentPointIndex < bezierPoints.Length)
                {
                    FollowBezierPath();
                }
            } 
        }

        private void SetbezierPoints(Vector3[] bezierPoints)
        {
            this.bezierPoints = bezierPoints;
        }
        public override void WeaponUseLogic()
        {
            // 如果还没到达终点 不要执行这段代码
            if (!isSimulateEnd) return;
            // 如果到达目的地了 
            if (Vector3.Distance(transform.position, lineRenderScript.endPoint) <= 0.05f)
            {
                // 半径内的所有碰撞体 是否有敌人
                Collider[] hitColliders = Physics.OverlapSphere(transform.position, checkRadius);

                foreach (Collider collider in hitColliders)
                {
                    if (isEnemyHere == true) break;
                    if (collider.CompareTag("Enemy") && collider != null)
                    {
                        enemyCollider = collider;
                        isEnemyHere = true;
                        break;
                    }
                }
                // 如果附近没目标 直接消失 也许应该延时？
                // 否则吸附上去 持续 X秒 协程计时
                if (!isEnemyHere || enemyCollider == null)
                {
                    Destroy(gameObject);
                }
                else
                {
                    if (!isStartCoroutine) StartCoroutine(AttachAndDestroySelf());
                }
                return;
            }
        }

        IEnumerator AttachAndDestroySelf()
        {
            // 第二个参数把 子父物体的相对位置设置为0 直接穿模
            if(enemyCollider != null) this.gameObject.transform.SetParent(enemyCollider.transform, false);
            isStartCoroutine = true;
            yield return new WaitForSeconds(10f); // 黏住的时间
            Destroy(gameObject);
        }
        private void FollowBezierPath()
        {
            Vector3 targetPoint = bezierPoints[currentPointIndex];

            // 计算距离并判断是否已到达
            float distance = Vector3.Distance(transform.position, targetPoint);
            if (distance <= 0.05f)
            {
                // 直接设置到目标点，避免浮点数误差积累
                transform.position = targetPoint;
                currentPointIndex++;
                // 如果 已经超出数组大小 那么下一次不再模拟 转而处理到达目标点的逻辑
                if (currentPointIndex >= bezierPoints.Length)
                {
                    isFollowingBezier = false;
                    isSimulateEnd = true;
                }
            }
            else
            {
                // 正常移动
                transform.position = Vector3.MoveTowards(
                    transform.position,
                    targetPoint,
                    bezierSpeed * Time.deltaTime
                );
            }
        }

    }
}*/

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace KidGame.Core
{
    public class GlowBall : WeaponBase
    {
        [SerializeField] private Rigidbody rb; // 物理组件（需在Inspector赋值）
        private float checkRadius = 3f;         // 检测敌人的半径
        private bool isEnemyHere = false;
        private bool isStartCoroutine = false;
        private Collider enemyCollider = null;
        private bool isSimulateEnd = false;     // 是否到达终点区域

        // 物理参数（可在Inspector调整）
        [SerializeField] private float baseHorizontalSpeed = 10f; // 水平基准速度

        protected override void Awake()
        {
            base.Awake();
            // 初始化物理组件
            if (rb == null)
                rb = GetComponent<Rigidbody>();

            if (rb != null)
            {
                rb.isKinematic = true;    // 初始禁用物理（手持状态）
                rb.useGravity = true;     // 备用：发射时启用
                rb.drag = 0;              // 无阻力
                rb.angularDrag = 0;       // 无旋转阻力
            }
        }

        protected override void Start()
        {
            base.Start();
            // 手持时强制禁用物理
            if (isOnHand && rb != null)
            {
                rb.isKinematic = true;
                rb.velocity = Vector3.zero;
                rb.angularVelocity = Vector3.zero;
            }
        }

        protected override void Update()
        {
            base.Update();
            // 手持时保持物理禁用
            if (isOnHand && rb != null && !rb.isKinematic)
            {
                rb.isKinematic = true;
                rb.velocity = Vector3.zero;
                rb.angularVelocity = Vector3.zero;
            }
            // 发射后检测是否到达终点
            else if (!isOnHand && !isSimulateEnd)
            {
                CheckIfReachEnd();
            }
        }

        // 检测是否到达终点区域
        private void CheckIfReachEnd()
        {
            if (lineRenderScript == null) return;

            float distanceToEnd = Vector3.Distance(transform.position, lineRenderScript.endPoint);
            if (distanceToEnd <= 0.5f) // 终点区域半径（可调整）
            {
                isSimulateEnd = true;
            }
        }

        public override void WeaponUseLogic()
        {
            if (isOnHand) return; // 仅在发射后执行

            // 刚发射时：启用物理并应用初速度
            if (!isSimulateEnd && rb != null && rb.isKinematic)
            {
                rb.isKinematic = false; // 启用物理
                CalculateAndApplyInitialVelocity();
            }
            // 到达终点后：执行敌人检测逻辑
            else if (isSimulateEnd)
            {
                Collider[] hitColliders = Physics.OverlapSphere(transform.position, checkRadius);
                isEnemyHere = false;
                enemyCollider = null;

                foreach (Collider collider in hitColliders)
                {
                    if (collider.CompareTag("Enemy"))
                    {
                        isEnemyHere = true;
                        enemyCollider = collider;
                        break;
                    }
                }

                // 无敌人则销毁，有敌人则吸附
                if (!isEnemyHere || enemyCollider == null)
                {
                    Destroy(gameObject, 0.5f); // 延迟销毁，留缓冲
                }
                else if (!isStartCoroutine)
                {
                    StartCoroutine(AttachAndDestroySelf());
                }
            }
        }

        // 计算并应用物理初速度（核心逻辑）
        private void CalculateAndApplyInitialVelocity()
        {
            if (lineRenderScript == null || rb == null) return;

            Vector3 start = lineRenderScript.startPoint;
            Vector3 end = lineRenderScript.endPoint;

            // 1. 计算水平方向（XZ平面）
            Vector3 horizontalStart = new Vector3(start.x, 0, start.z);
            Vector3 horizontalEnd = new Vector3(end.x, 0, end.z);
            Vector3 horizontalDir = (horizontalEnd - horizontalStart).normalized;
            float horizontalDistance = Vector3.Distance(horizontalStart, horizontalEnd);

            // 2. 计算运动总时间（基于水平距离和基准速度）
            float T = horizontalDistance / baseHorizontalSpeed;
            T = Mathf.Max(T, 0.1f); // 避免时间过短导致速度异常

            // 3. 计算垂直方向初速度（基于物理公式）
            float verticalDisplacement = end.y - start.y;
            float gravity = Physics.gravity.y; // 重力加速度（Unity默认-9.81）
            float verticalVelocity = (verticalDisplacement - 0.5f * gravity * T * T) / T;

            // 4. 应用最终初速度
            Vector3 initialVelocity = horizontalDir * baseHorizontalSpeed;
            initialVelocity.y = verticalVelocity;
            rb.velocity = initialVelocity;
        }

        // 吸附到敌人并延迟销毁
        IEnumerator AttachAndDestroySelf()
        {
            isStartCoroutine = true;
            if (enemyCollider != null)
            {
                // 吸附到敌人（无相对位置偏移）
                transform.SetParent(enemyCollider.transform, false);
                // 禁用物理，避免持续受力
                if (rb != null)
                {
                    rb.isKinematic = true;
                }
            }

            yield return new WaitForSeconds(10f); // 持续10秒（可调整）
            Destroy(gameObject);
        }
    }
}